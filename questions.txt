What is the problem? Ideas of pipelines currently, or wirings of data and computations, are very useful in the way that we compute data. However, these have their limitations, like having to specify to store data over and over again, or losing data if a pipeline is abruptly shut down or needs to be changed. Moreover, pipelines can change over time, or can be imperative, making them unpredictable These are impossible to model with other libraries like Summingbird, which allows pipelines to be real-time or batch with implementations of Storm, which is a real-time computation platform for pipelines or Scalding, which is a batch computation platform for pipelines, or the libraries that it uses, which expects acyclic graphs.

Why is this an important problem? Specifying something like data stores for intermediate values multiple times in pipelines requires a lot of extra work, and for complex problems can have the developer to go out of their way to implement these issues. E.g. Fixr stopped using Spark because they had to go out of their way to implement some sort of incremental processing for every single step in their pipeline, leading to immense tedium, and a ton of changes if the project guidelines ever changed. Requirements for the pipeline can also change at any point from a prototyping phase to supporting a full project, with not a ton of support for adjusting from memory to a new data system. Moreover, if someone makes a mistake in the pipeline and has to re-run the entire pipeline, you could potentially lose a ton of computation work, recomputing things that have already been computed before.

Why is it hard? There are infinitely many exceptions to the rule. Some steps require different needs; Some steps may require to be run every week, while some are required to run almost instantly. Moreover, there will certain processes and certain requirements that you can't really think of, like some rare variation of provenance tracking or incremental processing. In order to use those, or any unique pattern, you most likely will require extra steps or extensions to all the steps that you have written, leaving the problem only partially solved, if they can be solved at all.
